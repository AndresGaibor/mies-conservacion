// Typesinterface CameraState {  stream: MediaStream | null;  currentFacingMode: 'user' | 'environment';  devices: MediaDeviceInfo[];}interface ProcessingResult {  success: boolean;  extractedTitle: string;  newName: string;  processedImageUrl: string;  originalSize: number;  processedSize: number;  format?: string;  metadata?: any;}interface ProcessedImage {  filename: string;  url: string;  name: string;}class MobileImageApp {  private camera: CameraState;  private currentImageBlob: Blob | null = null;  private elements!: {    video: HTMLVideoElement;    canvas: HTMLCanvasElement;    captureBtn: HTMLButtonElement;    switchCamera: HTMLButtonElement;    fileInput: HTMLInputElement;    uploadBtn: HTMLButtonElement;    previewImage: HTMLImageElement;    retakeBtn: HTMLButtonElement;    processBtn: HTMLButtonElement;    downloadBtn: HTMLButtonElement;    newPhotoBtn: HTMLButtonElement;    cameraSection: HTMLElement;    previewSection: HTMLElement;    resultSection: HTMLElement;    gallerySection: HTMLElement;    cameraError: HTMLElement;    resultTitle: HTMLElement;    resultNewName: HTMLElement;    resultSize: HTMLElement;    galleryGrid: HTMLElement;    toastContainer: HTMLElement;  };  constructor() {    this.camera = {      stream: null,      currentFacingMode: 'environment',      devices: []    };    this.initializeElements();    this.setupEventListeners();    this.initializeCamera();    this.loadGallery();  }  private initializeElements(): void {    this.elements = {      video: document.getElementById('video') as HTMLVideoElement,      canvas: document.getElementById('canvas') as HTMLCanvasElement,      captureBtn: document.getElementById('captureBtn') as HTMLButtonElement,      switchCamera: document.getElementById('switchCamera') as HTMLButtonElement,      fileInput: document.getElementById('fileInput') as HTMLInputElement,      uploadBtn: document.getElementById('uploadBtn') as HTMLButtonElement,      previewImage: document.getElementById('previewImage') as HTMLImageElement,      retakeBtn: document.getElementById('retakeBtn') as HTMLButtonElement,      processBtn: document.getElementById('processBtn') as HTMLButtonElement,      downloadBtn: document.getElementById('downloadBtn') as HTMLButtonElement,      newPhotoBtn: document.getElementById('newPhotoBtn') as HTMLButtonElement,      cameraSection: document.getElementById('cameraSection') as HTMLElement,      previewSection: document.getElementById('previewSection') as HTMLElement,      resultSection: document.getElementById('resultSection') as HTMLElement,      gallerySection: document.getElementById('gallerySection') as HTMLElement,      cameraError: document.getElementById('cameraError') as HTMLElement,      resultTitle: document.getElementById('resultTitle') as HTMLElement,      resultNewName: document.getElementById('resultNewName') as HTMLElement,      resultSize: document.getElementById('resultSize') as HTMLElement,      galleryGrid: document.getElementById('galleryGrid') as HTMLElement,      toastContainer: document.querySelector('.toast-container') as HTMLElement    };    // Create toast container if it doesn't exist    if (!this.elements.toastContainer) {      this.elements.toastContainer = document.createElement('div');      this.elements.toastContainer.className = 'toast-container';      document.body.appendChild(this.elements.toastContainer);    }  }  private setupEventListeners(): void {    // Camera controls    this.elements.captureBtn.addEventListener('click', () => this.capturePhoto());    this.elements.switchCamera.addEventListener('click', () => this.switchCamera());    this.elements.uploadBtn.addEventListener('click', () => this.elements.fileInput.click());    this.elements.fileInput.addEventListener('change', (e) => this.handleFileUpload(e));    // Preview controls    this.elements.retakeBtn.addEventListener('click', () => this.returnToCamera());    this.elements.processBtn.addEventListener('click', () => this.processImage());    // Result controls    this.elements.downloadBtn.addEventListener('click', () => this.downloadImage());    this.elements.newPhotoBtn.addEventListener('click', () => this.returnToCamera());  }  private async initializeCamera(): Promise<void> {    try {      this.elements.cameraError.style.display = 'none';            // Get available devices      const devices = await navigator.mediaDevices.enumerateDevices();      this.camera.devices = devices.filter(device => device.kind === 'videoinput');            // Show/hide switch camera button based on available cameras      this.elements.switchCamera.style.display =         this.camera.devices.length > 1 ? 'flex' : 'none';      // Start camera      await this.startCamera();      this.showToast('CÃ¡mara inicializada correctamente', 'success');    } catch (error) {      console.error('Error initializing camera:', error);      this.elements.cameraError.style.display = 'block';      this.showToast('Error al acceder a la cÃ¡mara', 'error');    }  }  private async startCamera(): Promise<void> {    try {      // Stop existing stream      if (this.camera.stream) {        this.camera.stream.getTracks().forEach(track => track.stop());      }      // Start new stream      const constraints = {        video: {          facingMode: this.camera.currentFacingMode,          width: { ideal: 1920 },          height: { ideal: 1080 }        }      };      this.camera.stream = await navigator.mediaDevices.getUserMedia(constraints);      this.elements.video.srcObject = this.camera.stream;    } catch (error) {      throw new Error('No se pudo acceder a la cÃ¡mara');    }  }  private async switchCamera(): Promise<void> {    try {      this.camera.currentFacingMode =         this.camera.currentFacingMode === 'user' ? 'environment' : 'user';      await this.startCamera();    } catch (error) {      console.error('Error switching camera:', error);      this.showToast('Error al cambiar la cÃ¡mara', 'error');    }  }  private capturePhoto(): void {    try {      if (!this.elements.video.videoWidth || !this.elements.video.videoHeight) {        this.showToast('Error: Video no disponible', 'error');        return;      }      const canvas = this.elements.canvas;      const context = canvas.getContext('2d');            if (!context) return;      // Set canvas dimensions to match video      canvas.width = this.elements.video.videoWidth;      canvas.height = this.elements.video.videoHeight;            // Draw video frame to canvas      context.drawImage(this.elements.video, 0, 0);            // Convert to blob      canvas.toBlob((blob) => {        if (blob) {          this.showPreview(blob);          this.showToast('ðŸ“¸ Foto capturada', 'success');        }      }, 'image/jpeg', 0.8);    } catch (error) {      console.error('Error capturing photo:', error);      this.showToast('Error al capturar la foto', 'error');    }  }  private handleFileUpload(event: Event): void {    const target = event.target as HTMLInputElement;    const file = target.files?.[0];        if (file) {      this.showPreview(file);    }  }  private showPreview(blob: Blob): void {    this.currentImageBlob = blob;    const url = URL.createObjectURL(blob);    this.elements.previewImage.src = url;    this.showSection('previewSection');  }  private async processImage(): Promise<void> {    if (!this.currentImageBlob) {      this.showToast('No hay imagen para procesar', 'error');      return;    }    try {      this.elements.processBtn.disabled = true;      this.elements.processBtn.textContent = 'Procesando...';      const formData = new FormData();      formData.append('image', this.currentImageBlob, 'captured-image.jpg');      const response = await fetch('/api/process-image', {        method: 'POST',        body: formData      });      if (!response.ok) {        throw new Error('Error en el servidor');      }      const result: ProcessingResult = await response.json();      this.showResult(result);    } catch (error) {      console.error('Error processing image:', error);      this.showToast('Error al procesar la imagen', 'error');    } finally {      this.elements.processBtn.disabled = false;      this.elements.processBtn.textContent = 'Procesar con IA';    }  }  private showResult(result: ProcessingResult): void {    this.elements.resultTitle.textContent = result.extractedTitle;    this.elements.resultNewName.textContent = result.newName;    this.elements.resultSize.textContent =       `${(result.originalSize / 1024).toFixed(1)} KB â†’ ${(result.processedSize / 1024).toFixed(1)} KB`;    // Set download link    this.elements.downloadBtn.onclick = () => {      window.open(result.processedImageUrl, '_blank');    };    this.showSection('resultSection');    this.loadGallery(); // Refresh gallery    this.showToast('âœ… Imagen procesada exitosamente', 'success');  }  private downloadImage(): void {    // This will be handled by the onclick event set in showResult  }  private returnToCamera(): void {    this.showSection('cameraSection');    this.currentImageBlob = null;        // Revoke object URL to free memory    if (this.elements.previewImage.src.startsWith('blob:')) {      URL.revokeObjectURL(this.elements.previewImage.src);    }  }  private async loadGallery(): Promise<void> {    try {      const response = await fetch('/api/images');      const images: ProcessedImage[] = await response.json();            this.elements.galleryGrid.innerHTML = '';            images.forEach(image => {        const item = document.createElement('div');        item.className = 'gallery-item';        item.innerHTML = `          <img src="${image.url}" alt="${image.name}" loading="lazy">          <div class="gallery-item-info">            <span class="gallery-item-name">${image.name}</span>          </div>        `;                item.addEventListener('click', () => {          window.open(image.url, '_blank');        });                this.elements.galleryGrid.appendChild(item);      });    } catch (error) {      console.error('Error loading gallery:', error);    }  }  private showSection(sectionId: string): void {    // Hide all sections    [this.elements.cameraSection, this.elements.previewSection,      this.elements.resultSection, this.elements.gallerySection].forEach(section => {      section.style.display = 'none';    });    // Show target section    const targetSection = this.elements[sectionId as keyof typeof this.elements] as HTMLElement;    if (targetSection) {      targetSection.style.display = 'block';    }  }  private showToast(message: string, type: 'success' | 'error' | 'info' = 'info'): void {    const toast = document.createElement('div');    toast.className = `toast toast-${type}`;    toast.textContent = message;        this.elements.toastContainer.appendChild(toast);        // Show toast    setTimeout(() => toast.classList.add('show'), 100);        // Hide and remove toast    setTimeout(() => {      toast.classList.remove('show');      setTimeout(() => {        if (toast.parentNode) {          toast.parentNode.removeChild(toast);        }      }, 300);    }, 3000);  }}// Initialize the applicationdocument.addEventListener('DOMContentLoaded', () => {  new MobileImageApp();});